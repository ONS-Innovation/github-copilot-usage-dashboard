{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GitHub Copilot Usage Dashboard","text":""},{"location":"#overview","title":"Overview","text":"<p>This project contains a dashboard which displays ONSDigital's GitHub CoPilot usage metrics via the GitHub RESTful API. The dashboard is written in Python and uses Streamlit to produce a quick, easy and responsive UI. This project also makes use of a library called Plotly to produce high quality and interactive graphs.</p> <p>Please Note: This project is a Proof of concept and may not comply with Civil Service/ONS best practices. This tool is only being used by a limited number of users.</p>"},{"location":"#techstack-overview","title":"Techstack Overview","text":""},{"location":"#streamlit","title":"Streamlit","text":"<p>Streamlit is a powerful web framework which promotes creating apps quickly and without the need of any frontend writing. This makes Streamlit well suited to the project due to the speed of development and heavy data focus. Streamlit also promotes interactivity within its apps which is crucial when making a dashboard as you want users to be able to play with the data to get the most from it. This project has been used as a proof of concept for Streamlit, testing its capabilities and potential for future projects. A small drawback is Streamlit's potential lack of accessibility. This project hasn't been accessibility tested but, due to its limited target audience, is still fit for purpose. Another limitation of the tool is its ability to be customised to look and feel like an ONS product. Streamlit offers customisation within its colour scheme and allows logos to be added, however it will still look like a Streamlit application.</p>"},{"location":"#plotly","title":"Plotly","text":"<p>Plotly is a graphing library used within the project. Plotly was chosen because of its high interactivity, ability to export and general ease of use alongside Streamlit. Other libraries, such as Matplotlib, were trialed alongside Plotly during early development. It was found that Plotly just generally suited Streamlit's feel and focus on interactivity, which is why it was chosen. Another advantage of Plotly was its incorporation with Dash, a dashboarding tool built on top of the Flask framework. This means that if Dash was to be used in the future (perhaps to onboard a dashboard onto the ONS Design System), we'd already have some knowledge on how to use it.</p>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>This project uses 3 major components:</p> <ul> <li>The Dashboard</li> <li>The Lambda Function</li> <li>The GitHub API Toolkit (stored in another repository - Repository Link)</li> </ul>"},{"location":"#the-dashboard","title":"The Dashboard","text":"<p>This component is responsible for displaying data back to the user. The dashboard gathers live data from the GitHub API using the API Toolkit. If this process fails, it will display the example dataset (stored within ./src/example_data) instead. The dashboard also gathers the historic data from an S3 bucket.</p>"},{"location":"#the-lambda-function","title":"The Lambda Function","text":"<p>This component updates the dashboard's historic information, stored within an S3 bucket. The lambda imports the GitHub API Toolkit to get the API response containing the usage information. The script then adds any new data to the existing historic data within the S3 bucket.</p>"},{"location":"#the-github-api-toolkit","title":"The GitHub API Toolkit","text":"<p>This component is an imported library which is shared across multiple GitHub tools. The toolkit allows applications to make authenticated requests to the GitHub API. It is imported and used by both the dashboard and lambda function.</p>"},{"location":"#high-level-data-overview","title":"High Level Data Overview","text":""},{"location":"#live-data","title":"Live Data","text":"<p>The data used within this section of the tool is pulled directly from the GitHub API at runtime. This data is dependant on a GitHub App being setup within the target organisation, with the correct permissions (as outlined in the README).</p>"},{"location":"#example-data","title":"Example Data","text":"<p>In the event that the dashboard cannot access live data from the GitHub API, the dashboard has an example dataset stored within the repository. These have been sourced from this repository. The datasets mirror the response which an API call would make.</p> <p>The 2 datasets are:</p> <ul> <li>copilot_usage_data.json (from this endpoint)</li> <li>copilot_seats_data.json (from this enpoint)</li> </ul> <p>These endpoints are both in beta (as of 21/05/24) and may change in the future.</p>"},{"location":"#historic-data","title":"Historic Data","text":"<p>This section gathers data from AWS' S3. The CoPilot usage endpoints have a limitation where they only return the last 28 days worth of information. To get around this, the project has an AWS Lambda function which periodically stores data within an S3 bucket. For more information, look at the README.md within the /aws_lambda_script directory (link).</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To setup and use the project, please refer to the READMEs placed within each module.</p> <ul> <li>Dashboard Setup</li> <li>Lambda Setup</li> </ul>"},{"location":"documentation/","title":"Documentation","text":"<p>This site uses MkDocs to build its documentation and GitHub Pages for hosting.</p>"},{"location":"documentation/#format","title":"Format","text":"<p>Documentation within this project follows the following pattern:</p> <ul> <li>A <code>README.md</code> for each component</li> <li>A <code>/docs</code> folder for the project</li> </ul> <p>Each <code>README.md</code> should contain:</p> <ul> <li>A description of what the component is/does</li> <li>A list of any prerequisites</li> <li>Setup instructions</li> <li>Execution instructions</li> <li>Deployment instructions</li> </ul> <p>The <code>/docs</code> folder should contain:</p> <ul> <li>A description of what the project is</li> <li>An overview of how the everything fits together in the project</li> <li>An explanation of the tech stack</li> <li>Details of the underlying dataset</li> </ul> <p>A majority of the information should reside within the <code>/docs</code> directory over the <code>README</code>. The <code>README</code>s in this project should be kept for concise instructions on how to use each component. Any detailed explanation should be kept within <code>/docs</code>.</p>"},{"location":"documentation/#getting-mkdocs-setup","title":"Getting MkDocs Setup","text":"<p>In order to build an MkDocs deployment or serve the documentation locally, we need to install MkDocs and its dependencies.</p> <ol> <li> <p>Navigate into the project's root directory.</p> </li> <li> <p>Install MkDocs and its dependencies.</p> <pre><code>pip install -r mkdocs_requirements.txt\n</code></pre> </li> <li> <p>You can now use MkDocs. To see a list of commands run the following:</p> <pre><code>mkdocs --help\n</code></pre> </li> </ol> <p>Please Note: Python's package manager, PIP, is required to install MkDocs. Please make sure you have Python installed beforehand.</p>"},{"location":"documentation/#updating-mkdocs-deployment","title":"Updating MkDocs Deployment","text":"<p>If changes are made within <code>/docs</code>, the GitHub Pages deployment will need to be updated. Assuming you have already installed MkDocs and Material for MkDocs, do the following:</p> <ol> <li> <p>Navigate to the projects root directory.</p> </li> <li> <p>Delete the existing <code>/mkdocs_deployment</code> directory.</p> </li> <li> <p>Build the MkDocs deployment.</p> </li> </ol> <pre><code>mkdocs build\n</code></pre> <ol> <li> <p>Rename the <code>/site</code> directory to <code>/mkdocs_deployment</code>. This allows git to track the build so GitHub Pages can redeploy it.</p> </li> <li> <p>Commit and Push changes.</p> </li> </ol> <p>Once completed, a GitHub Action will redeploy the new build to GitHub Pages.</p>"}]}